---
id: libs
title: Linkers, Loaders and Libraries
sidebar_label: Linkers, Loaders and Libraries
---

## C compilation process

![https://people.cs.pitt.edu/~xianeizhang/notes/Linking.html](/img/compiler_driver.png)
[credits](https://people.cs.pitt.edu/~xianeizhang/notes/Linking.html)

```shell
# Preprocessor converts source code into ascii intermediate file.
# Also called the Translation unit
# https://en.wikipedia.org/wiki/Translation_unit_%28programming%29
$ cpp main.c main.i
$ gcc -E main.c -o main.i # same as the previous command
```

```shell
# Compiler converts ascii intermediate file into assembly file.
# In reality you don't call directly cc1, gcc calls cc1 for you.
$ cc1 main.i -o main.s
```

```shell
# Assembler translates assembly file to binary reloc. obj file
$ as -o main.o main.s
```

In the linking phase, we have two [compilation flavours/envs](https://wiki.osdev.org/C_Library) to think about:

- **Hosted(`-fhosted`)** where the c standard library is available. Usually provided by the OS.
- **Freestanding(`-ffreestanding`)** where only a few headers are usable that contains only defines and types. This is mostly the case with embedded systems.

> **Aside about CRT (C Runtime)**
>
> In a hosted environment, a program is loaded into memory by a loader which is responsible for setting up the ELF segments etc. once the segments are loaded the [crt0](https://en.wikipedia.org/wiki/Crt0)(`.s`/`.o`) can do its initilization stuff(populate `argv` etc.) and setup the C runtime environment and then call `main`(`libc.so.6:__libc_start_main` then calls out `main`). `main` function is an idea of the c language not relating to assembly language or the linker. `crt0` is like a shim layer between the program loader(eg. `execve`) and your program.
>
> The linker controls the program's entrypoint and in general gcc points the entrypoint to `_start` and [`crt0` defines the content of the `_start`](https://en.wikipedia.org/wiki/Crt0#Example_crt0.s). If the linker cannot not find the `_start` symbol, it'll set the entrypoint to the beginning of the `.text` segment.

> ðŸ”Œ For embedded environment, since there is no loader available the `crt0` has more work to do, such as exception vector setup, initilizing the stack and frame pointers etc. It's also useful to supply your own `_start` when you want to write really tiny programs or programs that do unconventional things.

- `PLT[1]` calls `libc_start_main`

```shell
# Linker combines other obj, shared obj and generates the exec obj.
# Following commands won't work because how the C standard library is linked.
# run gcc with the -v to see the linker commad that gcc runs
# collect2 is alias for ld.
$ ld -o main main.o
$ ld -e main -dynamic-linker /usr/lib64/ld-linux-x86-64.so.2 main.o -lc
```

```shell
# Loader executes the program
$ ./main
# Also could see the loading with:
$ strace ./main
```

### Assembly Code

Human readable code, that has 1:1 analogous to machine instructions. **assembler** is used convert assembly code to relocatable object code.

It is possible to have different syntax for assembly language. Eg. for x86, In original Intel syntax `add eax,[ebx]` will add memory data to a register; whereas this would be written as `addl (%ebx),%eax` in the AT&T syntax, both of them would map to the same machine instruction. The [assembler decides](https://linux.die.net/man/1/as) which syntax to support, it can also support multiple syntax.

### Machine code

Machine code is code that is directly executable by the computerâ€™s physical processor without further translation. Load into memory and go. Languages like C generate machinecode in the end rather than something like bytecode.

### Object Code

- These are binary files but not necessrily machine code which contain additional metadata that will enable a linker, loader to assemble it with other object code modules into executable machine code or bytecode.
- **Relocatable object files(`.o`)** and **shared object files(`.so`)**(_relocatable object files that can be linked dynamically_) are generated by _compiler_ or _assembler_.
- **Executable object files(`a.out`, usually no extension)** are generated by _Linker_. These can be directly copied into memory and executed.
- Can have various formats, `a.out`(historical), `PE`, `Mach-O`, `ELF`. But `ELF` is super common and is a common formot for all the 3 types of object files mentioned.

### Bytecode

Byte code is code that can be executed and understood by a virtual machine/runtime. The virtual machine implementation reads the bytecode and performs the operations it specifies within a virtual environment. Byte code is typically slower than machine code but is **portable across platforms**. Languages/runtime that use bytecode include Java, Python, [Dalvik/ART](https://en.wikipedia.org/wiki/Android_Runtime), Lua, WebAssembly etc.

Eg. Bytecode is sort of the object code for the JVM. But, an object code isn't necessarly bytecode.

![](/img/x-code-ven.png)

## Background and Jargons

### Flat Binary

Binary files are just sequence of bytes in a file instead of text files. They can be compiled computer programs aswell as images, videos etc. Usually binary files contain some header for metadata which can contain some **magic number** to identify the format of the binary file. Binaries that do not contain any header are called **flat binaries.**

### Binary and Executables

[When speaking casually](https://www.reddit.com/r/linux/comments/56mc2d/the_101_of_elf_binaries_on_linux_understanding/d8l38rv/) we sometimes mix binaries and executables, they are not the same. Not all binaries are executables. eg. Object code are binaries but they are not executables, on the other hand a directory can be an executable. ELF can be used both for executables and non-executable binaries. To confuse this even more, some references use the terms _relocatable object file_(for object files) and _executable object file_(for executables obtained from relocatable object file).

### Loader

Loader is a program in the operating system that takes a **program** from disk and loads it into memory. In linux world we can use [execve() system call](https://geekodour.xyz/post/exec-family/) to invoke the program loader.

Loader has many things to do such as:

- Check permissions, Allocate space for the programâ€™s stack
- Allocate space for the programâ€™s heap, Initialize registers (e.g., stack pointer)
- Push argc, argv, and envp onto the program stack, Map virtual address spaces
- Dynamic linking, Relocations, Call pre-initialization functions

Once it does all this, just call into the entrypoint which is generally `_start`

Linux loads the .text section into memory only once, no matter how many times an application is loaded. This reduces memory usage and launch time and is safe because the code doesn't change. For that reason, the .rodata section, which contains read-only initialized data, is packed into the same segment that contains the .text section. The .data section contains information that could be changed during application execution, so this section must be copied for every instance.

> you should load the segments, not the sections. Load the segment if it is of type `PT_LOAD`, `LOAD`.

## Symbols

When you write a program in any language above direct machine code, you give symbolic names to functions and data and the compiler turns these things into code. At the machine level, they are known only by their address (offset within the file) and their size. But we need some way to refer to these, Symbols.

In the C compilation process:

- **The compiler(cc1)** generates assembly file(`.s`) which contains the symbols in text format, the compiler may do any sort of name mangling here(_eg. sometimes it optimizes unused variables/extern vars so they never make to the symbol table!_)
- Now **the Assembler** takes the `.s` file and creates the obj file. While doing so, it creates the symbol table in the `.symtab` section of the ELF object. In ELF64, `.symtab` contains an array entries of struct `Elf64_Sym`.
- Now **the linker/static linker/link editor** will look into `.symtab`, `.rel.text`, `.rel.data` to perform symbol resolution and relocation, for dynamic executables it'll leave some of the linking to the loader/dynamic linker.
- **The loader** makes use of the program header table to determine what things to put in memory for creating process images etc.
- If **lazy loading**(which is the common case), the shared library is not loaded until a function in itâ€™s library is loaded by **the dynamic loader**. (GOT and PLT stuff.)
- Lazy binding requires use of the PLT; with -fno-plt all external symbols are resolved at load time.

> **Dynamic Symbol Table**
>
> `.dynsym` is a smaller version of `.symtab` that only contains global symbols. The information found in the `.dynsym` is therefore also found in the `.symtab`, while the reverse is not necessarily true. For storing null-terminated strings, `.dynstr` is used with `.dynsym`. The symbols in `.dynsym` are called **dynamic linker symbols.**
>
> also found in shared objs
>
> got and plt seem to be there no matter if you compile with --no-pic/-no-pie
>
> This does not exist in the reloc. obj file.
>
> some [good historical context](https://blogs.oracle.com/solaris/inside-elf-symbol-tables-v2)
>
> .symtab is for the linking step of the shared lib itself. Once linking is finished, the .symtab section is not needed anymore. The .dynsym section contains important symbols that are supposed to be searched by the dynamic linker at run time.
>
> TODO: Are these table/section dynamic linking specific? How does static linking work then if processes do not use `.symtab`, program header?? `.dynsym`, on the otherhand, is needed at runtime, so it is kept in the process image. any relation to the PTL or whatever.

### Symbol Sections

I don't think there is a thing called "symbol section", but symbol table just contains references and information about the symbol while the real value of the symbol can exists in different sections of the object file. Eg. `.text`, `.data` etc. Symbols use the `st_shndx` field to specify the section header index of the section where the value lives in. When doing `readelf -s` it's the `Ndx` column.

There are a few pseudosections which are not defined by ELF, such as `UNDEF`,`COMMON`,`ABS` in to which the symbol may reference its value to. Unsure but most probably this is based on the `st_info` described below.

> The number of such sections depends on the hardware platform. On an x86_64 system over 30 special sections are defined, while on an ARM system there are about ten. One could define their own special section in linux.

### Symbol Information

`st_info` field contains symbol's type and binding attributes, these are very useful for the link-editor.

#### Symbols Types

`STT_NOTYPE`, `STT_OBJECT`, `STT_FUNC`, `STT_SECTION`, `STT_FILE`, `STT_COMMON`, `STT_TLS`, `STT_LOOS`, `STT_HIOS`, `STT_LOPROC`, `STT_SPARC_REGISTER`, `STT_HIPROC`

See [Undefined, Tentative(`STT_COMMON`), Defined.](https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-79797.html#scrolltoc)

#### Symbol Bindings

`STB_LOCAL`, `STB_GLOBAL`, `STB_WEAK`, `STB_LOOS`, `STB_HIOS`, `STB_LOPROC`, `STB_HIPROC`

##### Strong and Weak Symbols

When multiple global variables are declared on object files, linker uses the idea of strong and weak symbols to choose which one to use.

```c
int x; // weak global symbol - STB_WEAK
int y=10; // strong global symbol - STB_GLOBAL
```

##### Global, Local and Extern

- Global Symbols : **Defined** by `m` which can be referenced by other modules. `STB_GLOBAL`
- External Symbols : `Global Symbols` that are **referenced** by `m`, but by some other module. `STB_GLOBAL`
- Local Symbols : **Defined and referenced** exclusively by `m`, `STB_LOCAL`

|                     |                           `static`                           |            non-`static`            |
| ------------------- | :----------------------------------------------------------: | :--------------------------------: |
| **Global Variable** |                         Local Symbol                         |           Global Symbol            |
| **Local Variable**  | Local Symbol \w unique name<br/>_(stored in `.data`/`.bss`)_ | Maintained at runtime on the stack |
| **Global Function** |                         Local Symbol                         |           Global Symbol            |
| **Local Function**  |                        No such thing                         |           No such thing            |

## Symbol Resolution

The purpose of symbol resolution is to associate each symbol reference with exactly one symbol definition. There are three places where symbol resolution can happen. **run-time, link-time and compile-time.** We call it dynamic linking, when it's happening at loadtime or runtime.

### Compile Time Symbol Resolution

The compiler just looks at the ascii intermediate code and generates symbols in the assembly file. It does not not create the symbol table yet.

> Sometimes compile-time is referenced for Link-time aswell.

### Link Time Symbol Resolution

As we know that the **assembler** puts the symbols generated by the **compiler** into symbol table at the `.symtab` section in the elf object file which the **linker** then uses, so these symbols at the `.symtab` are sometimes also refered to as **linker symbols**.

Static Linker (which alwas [be using linker scripts](http://sourceware.org/binutils/docs/ld/Scripts.html)) uses the [symbol information](#symbol-information) and reloc. info to make decisions to how to reference and relocate things. Sometimes it does it absolutely and sometimes it does the linking partially so that the dynamic linker(`ld.so`) can do rest of the linking.

```c
void swap() {...} /* define symbol swap */
swap();           /* reference symbol swap */
int *xp = &x;     /* define symbol xp, reference x */
```

- [How to Write Shared Libraries by Ulrich Drepper](https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf)

### Load Time Symbol Resolution

The Static Linker(ld) creates the executable but does not link the shared libraries but does make a note of which shared lbraries to load so that the loader/runtime can load them as required. This is partially linking. The loader(execve syscall) inturn calls the dynamic linker (ld-linux.so)

### Run Time Symbol Resolution

Also when running the program, the dynamic linker is used to figure out the symbols of shared libs along with GOT and PLT. Once could resolve symbols while the program is running aswell with functions such as `dlopen`.

## PIC,PIE,GOT and PLT

### PIC

The idea behind PIC is simple - **add an additional level of indirection to all global data and function references in the code**. It's an old concept that we needed when we needed to load multiple programs into the same physical address space but became less useful as we moved to virtual address spaces, but with **shared libraries** we have the need to use PIC again since we don't want shared libraries to be overlapping and we do not know which virtual address that shared library will run at.

Before PIC we're using [load time relocation for shared libraries](#shared-libraries) which made the dynamic linker do a lot of relocation during runtime. PIC practicaly eliminates all absolute addressing, replacing it with either relative addressing or a small jump table that can be forked for each process and for different processes, the same shared library will run at different address, depending on the decisions made by the dynamic linker.

#### Static Libraries and PIC

> - DOUBT: Apparently there is a difference between -fpic and -fPIC and the same for pie!
> - Objects can be PIE?

- Traditionally, static libraries are compiled without -fPIC on Linux because it usually doesn't have much use(as resolution is already done by link-editor) and on some architectures there is a small performance penalty for using it.

Super confusing:

- diff btwn -fpic and -fPIC https://stackoverflow.com/questions/3544035/what-is-the-difference-between-fpic-and-fpic-gcc-parameters?rq=1
- , if you intend to link shared libraries against it(static), you need PIC code in your static library.

- Position Independent executables may be created from PIC or PIE objects (.o) and PIC or PIE static libraries (.a)
- PIC shared libraries can only be created from PIC objects or static libraries
- Non-PIE executables1 can be created from any objects or static libraries
- If the object is to be linked as a shared library, or a static library that will in turn be linked in a shared library, use -fPIC
- If the object is to be linked as a position indenpendent executable, or astatic library that will in turn be linked in position independent executable, use -fPIE

### ASLR

- out of many things, having aslr makes it hard for the attacker to guess the address space of a program.
- Idea is that appications run in a randomized address space.
- When debugging with gdb, it kind of disables aslr so if you run, if you want gdb to use asle address better used the pid

```shell
Î» sudo sysctl -a | grep 'randomize_va_space'
146:kernel.randomize_va_space = 2
```

### PIE

- PIE executables are sort of a hack using a shared object with an entry-point.
- The only real difference between PIE and PIC is that you are allowed to interpose symbols in PIC, but not in PIE. Except for that, they are pretty much equivalent.
- https://www.drdobbs.com/building-library-interposers-for-fun-and/184404926
- no diff between shared lib and pie exec. both dyn see with -no-pie -no-pic etc.
  Before the early 2000s, PIC was limited to shared libaries. Then PIE came to solve some security concerns.
- PIE executables will be using relative addressing, but On the other hand, a non-PIE executable is always loaded at its linked-at address. On Linux, the default address for x86_64 binaries is 0x400000, and so the .text ends up not far from there.

* PIE in statically linked binaries is also done.
* Nowadays, position independent executables (PIE) are the default on distros such as Ubuntu 18.04.
* To address what -pie does, it produces an executable that can be loaded at an arbitrary base address, rather than "normal" executables whose load addresses are fixed at ld-time. These use the same type of position-independent code and load headers used in shared libraries, which are also loadable at arbitrary addresses. PIE is generally considered a hardening mechanism (allowing address randomization to affect the address of code and data in the main program) but it can also have other uses like making binaries more appropriate for MMU-less systems.
* https://en.wikipedia.org/wiki/Address_space_layout_randomization
* https://en.wikipedia.org/wiki/Return-to-libc_attack (nx bit cannot prevent this, aslr can)
* The presence of the PHDR and INTERP headers indicates that -pie silently overrides -static in the arm compiler.
* PIE is to support address space layout randomization (ASLR) in executable files.
* PIE is just PIC but for executables and addition to some optimizations in pie, It works very much like what PIC does for dynamic libraries, the difference is that a Procedure Linkage Table (PLT) is not created, instead PC-relative relocation is used.
* When using PIE, A dynamic linker does full relocation processing on the program module, just like dynamic libraries. Any usage of global data is converted to access via the Global Offsets Table (GOT) and GOT relocations are added.
* When GCC compiles executable by defaults it makes them PIE which changes the output flag on the ELF Header to ET_DYN. gcc -no-pie to disable. It appears that the main effect of ET_EXEC vs ET_DYN in the Linux kernel / dynamic loader is to inform if the executable can be placed in random memory locations or not with ASLR.
* [Scrt1.o is used](/txt/crt.txt) in place of crt1.o when generating PIEs. PIE is normally linked with Scrt1.o, but a shared library is normally not. But there is nothing to prevent a shared library to be linked with Scrt1.o as well,
* The distinction between "executable" and "shared object" is largely artificial. What the file command is showing you is whether the ELF e_type header is ET_EXEC or ET_DYN. This is a rather technical distinction and has to do with how the loader treats them. file (via its magic file) should probably be taught to distinguish between "shared object" in the sense of "shared library" and "PIE executable" by looking for other characteristics like the presence of a PT_INTERP program header (which libraries generally won't have) or perhaps an entry point address (although some libraries seem to have a meaningless one).

### PLT

For calls made from PIC code, you are correct that the PLT is not really needed. The compiler could just was well generate a GOT lookup and indirect call to the address obtained from the GOT. Using a PLT tends to make the code slightly more efficient though

- Position independent code will call non-static functions via the Procedure Linkage Table or PLT.

- Where the PLT is absolutely needed, however, is in non-PIC code that's dynamic linked.
- shared libs must be using pic

PLT stands for Procedure Linkage Table which is, put simply, used to call external procedures/functions whose address isn't known in the time of linking, and is left to be resolved by the dynamic linker at run time. (TODO: runtime or loadtime or both?)

the dynamic linker checks the address of shared libraries, and hacks up the GOT and PLT so that it will point correctly to the required shared library symbols

- For functions you need PLT+GOT, Procedure calls inside a shared library are typically made through small procedure linkage table stubs, which then call the definitive function.

### GOT

- Global Offset Table or GOT. This is used for global and static variables.
- For vars only GOT can work
- For every reference to a global variable from position independent code, the compiler will generate a load from the GOT to get the address of the variable, followed by a second load to get the actual value of the variable.
- The program linker will create the dynamic relocations which the dynamic linker will use to initialize the GOT at runtime.
- Unlike the PLT, the dynamic linker always fully initializes the GOT when the program starts.
- Data references from position-independent code are usually made indirectly, through Global Offset Tables (GOTs), which store the addresses of all accessed global variables.
- There is one GOT per compilation unit or object module, and it is located at a fixed offset from the code (although this offset is not known until the library is linked). When a linker links modules to create a shared library, it merges the GOTs and sets the final offsets in code. just like the linker merges the text sections into one.
- each process has its own GOT and PLT that other lib trying to access the location uses.

GOT stands for Global Offsets Table and is similarly used to resolve addresses. Both PLT and GOT and other relocation information is explained in greater length in this article.

> Are GOT and PLT only used with PIC and PIE? : PIC is implemented by GOT and PLT. But GOT and PLT tables can be seen even when compiled with --no-pic and -no-pie. (TODO) even when passed the --static flag! When passing the --static flag there is no [.dynamic section](https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-42444/index.html) doe.

## Libraries

When writing programs we need some way to package commonly used functions, for this we need libraries. Just like [symbol resolution](#symbol-resolution), libraries can be loaded in three different ways: **Compile time, Load time, Run time** because loading libraries is essentialy resolving symbols and relocating references.

> **About the C standard library**
>
> The files that we include using the `#include` directives are just header files that consists of defines and types, these are added to the ascii intermendiate file in the preprocessing phase itself. For eg. `#include<stdio.h>` The functions mentioned in this header file need to be implemented by the C standard library, which is later linked by the dynamic linker. There can be multiple implementation of the [C standard library.](https://wiki.osdev.org/C_Library)
>
> Be aware that statically linking glibc is strongly advised against by the glibc maintainers, and some features of glibc will not work when statically linked.

### Library Naming Convention

Some observations:

- The convention of these library names is that you need to prefix with `lib<name>.a` same for `lib<name>.so`. Eg. `libc.so`,`libm.a`etc. This prefix-suffix is not actually mandated, it's a convention and based on how the `-l` flag does lookup for libraries.
- Some `.so` and `.a` flags are ld scripts! Eg. `/usr/lib/libm.so` the real library filename in this case is `/usr/lib/libm.so.6`
- Need to read more on SONAME and versioning.(TODO) Allows incremental updates just by recompiling and rearchiving.

### Static Libraries

These are the `.a`(archive) files or a collection of `.o` files. Basically concats the relocatable object files into one file with and index (called archive). These are not ELF files but rather archive files generated by the `ar` command.

#### Linking static libraries

When linking a static library to a file, if symbol is found to be in one of the reloc files from the index, it'll link the entire objectfile to the executable. Ordering of `-l` flag matters, most compilers expect it to be after the filesnames(eg. main.c).

- linking against a static library is roughly the same as just adding more .o files to the linker line.
- You can also link a static library into a shared library - the code in the static library is then just copied into the shared library (but the code then must be compiled with -fPIC, as with all other code that is used in shared libraries).
- since .o files can be generated with -fpic and -fpie, It's therefore in possible to generate a static library with code that was compiled with either -fPIC or -fPIE.

#### Static Libraries vs Static Binaries

`-static` tells the compiler driver that the linker should build a fully linked executable obj file that can be loaded into memory and run without any further linking at load time. but -static by itself does not pickup the static library instead of the shared one when linking (investigate)

- If both static and shared libraries are found, the linker gives preference to linking with the shared library unless the -static option is used.

- In Unix, the default compilation mode for programs is to use the systems shared library, instead of pre-linking everything necessary in the executable. When compiling a program with gcc, for instance, you pass the -static flag if you wish it to be statically compiled, instead of having unresolved symbolic references.
  {TODO}

- the idea that -static does not tell gcc to include libc.a is olop doubtful now.

### Shared Libraries

Shared libraries have many names - shared libraries, shared objects, dynamic shared objects (DSOs), dynamically linked libraries(DLLs). With shared libraries we face a problem, each program can use any number of shared libraries, and there's simply no way to know in advance where any given shared library will be loaded in the process's virtual memory. There are two well known ways to resolve this:

- [Load-time relocation](https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id14) : x86-64 no longer supports load time relocation for shared objects, it'll still work on i386. This will cause the program linker to generate a lot of relocation information, and cause the dynamic linker to do a lot of processing at runtime.
- [Position Independent Code (PIC)](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/)

### PIC,PIE,Shared, Static Matrix

Some notes about the flags:

#### Code Generation Options

- -fpic
- -fPIC
- -fpie
- -fPIE

#### Options for linking

(these are not linkeroption, i.e cannot pass to ld, gcc options only)

- most distos use -fPIE and -pie by default.
- --enable-default-pie / gcc configured with this option
- if we just use -pie and it should fail because then the generated code will be using absolute addressing which is not compitable with -pie. so both -fPIE and -pie

So basically, gcc builds with -fPIE, we can use -fPIC when using shared and futher to not use postion independet anything we can do -fno-pic , -no-pic is different because it's not related to code generation.

- -pie
- -no-pie
- -static-pie
- -static
- -shared
- -rdynamic

* -static and -pie are incompatible for x86?
* -no-pie does not mean static
* --shared does not mean -fpic
* --no-pic does not mean idk what lol
* rdynamic flag?

```shell
clang++ -o random.o -c random.cpp
clang++ -shared -o librandom.so random.o
clang++ -o main.o -c main.cpp
clang++ -o main main.o -lrandom -L. #if -l and -L not provided will fail
```

```shell
# create
$ gcc -shared -o libvector.so addvec.c multvec.c
```

```shell
# Tell linker which libraries to load
# -L tells Linker which directory to look for library first
# -l is just a shorthand, we could use -libmath or -lmath
# ordering matters with static libraries
```

```shell
# creating shared lib
$ g++ -shared -fPIC -c test.cpp -o test.out && ld -o libtest.so test.out
ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
```

```shell
# creating statcic lib
$ g++ -fPIC -c test.cpp -o test.out && ar rcs libtest.a test.out
```

```shell
# create
Î» ar rcs libmylib.a file2.o
# location: /usr/lib
Î» ar -t libc.a|sort|head -n 2
a64l.o
abort.o
```

### Env & Setting up of Libraries

- LD_LIBRARY_PATH
- we can replace functions on the fly by playing with the LD_PRELOAD variable
- LD_DEBUG
- dlopen
- ld.so.preload
- `ldconfig` reads the content of /etc/ld.so.conf, creates the appropriate symbolic links in the dynamic link directories, and then writes a cache to /etc/ld.so.cache which is then easily used by other programs.
- According to ldconfig(8), /etc/ld.so.conf is there for creating a cache (/etc/ld.so.cache) with paths to dynamic libraries. The dynamic linker (ld.so) then uses that cache to determine which libraries to link in when executing an a.out or ELF file.
- According to ld.so(8), /etc/ld.so.preload serves the same purpose as setting the LD_PRELOAD variable, i.e. as a means to temporarily linking in a different library than usual.
- once we update the ldconfig file, we still need to update the cache.

## Linker's Work

The GNU Binutils linker uses a linker script that determines how sections are placed inside segments in, and many other properties of the executable output.

http://sourceware.org/binutils/docs/ld/Scripts.html

The linker merges together all sections of the same type included in the input object files into a single section and assigns an initial address to it. For instance, the .text sections of all object files are merged together into a single .text section, which by default contains all of the code in the program. The linker always uses a linker script. If you do not supply one yourself, the linker will use a default script that is compiled into the linker executable. The main purpose of the linker script is to describe how the sections in the input files should be mapped into the output file, and to control the memory layout of the output file.

### How memory is laid out

The starting point address is part of a set of conventions which describe how memory is laid out. The linker, when it produces an executable binary, must know these conventions as it dectates how the executable is formed.

The memory layout conventions can be changed, we're talking the memory layout of executables in linux.

> Why .text segment be loaded at 0x400000;
>
> Set where the text segment will be loaded into memory by Linux. Linux segfaults us if the .text is too low. If this were not present, it would be 0, and that is too low and segfaults.
> https://stackoverflow.com/questions/39689516/why-is-address-0x400000-chosen-as-a-start-of-text-segment-in-x86-64-abi/39692117

ld -verbose | grep -i text-segment chooses 0x400000 for 32bit it is 0x08048000

### Symbol resolution step

something

### Relocation step

elocations are entries in binaries that are left to be filled in later

- Dynamic relocation vs object file relodation, dyn relec is done my ld.so, Not only shared objects but also dynamic (non-static) executables may have dynamic relocations.
- The linker relocates these sections by associating a mem location with each symbol definition, and then modifying all of the references to those symbols so that they point to this mem loc.

When an assembler generates an obj module, it does not know where the code and data will ultimately be stored in memory.(?) Nor does it know the locs of any externally defined funcs or global vars that are referenced by the module.

When code is compiled, the compiler does not know which address the linker is going to pick. So it calculates creates reminders to the linker called the relocation entries which are stored in `.rel.data` and `.rel.text` that the linker can later use.

Relocates symbols from their relative location in the `.o` files to their final absolute memory location in the executable where it merges all the modules together. Also updates all the references to the new location/position.

Executable does have segments mapped to .rela.dyn .rela.plt doe.

So linker add valid absolute addresses to the executable.

There are also load time relocation and link time relocatoion (eli post)
https://linux.die.net/man/1/ld but it has the --dynamic-linker flag aswell
https://linux.die.net/man/8/ld-linux.so

- More fuckedup shit: The dynamic linker (ld.so) then uses that cache to determine which libraries to link in when executing an a.out or ELF file.

## Misc

### Making small executables

> The section table(`.symtab`) can be [stripped](https://sourceware.org/binutils/docs/binutils/strip.html) for executables or shared objects because it is nither used by the **dynamic linker**(`ld.so`) not by the os loader. It's only used by the **static linker/link-editor**(`ld`).
>
> Relocation info(`.rel_text`,`.rel_data`) already stripped by the linker after relocating.
>
> One could also use "-n" (also known as "-nmagic") linker option. This basically tells ld to not worry about aligning program sections on page boundaries. Further to strip, one could also use `sstrip`.
>
> Some dynamic relocation section such as `.rela.dyn` can still be found in the the exec binary(both for `ET_DYN` and `ET_EXEC`)

### vdso(vDSO)

linux-vdso.so.1 is a virtual library that is automatically mapped in the address space of a process by the kernel, it does not have a filename but has and address when we do ldd.

it's an way to export kernel space routines to userspace. The main reason is to reduce the system call overhead. Typically when a system call happens it requires some expensive operations like switching mode from user to kernel, copying data from userspace to kernelspace etc. To reduce these sorts of overhead VDSO is used, just by reading that vdso memory space result could be extracted i.e it's possible to `gettimeofday()` without doing a real system call!

Note, not all system calls have VDSO support, only system calls like getcpu(), gettimeofday(), time() etc. which is an extremely fast way to get these thing done. Also the memory address linux-vdso.so.1 points is randomized, on different ldd invocation you'll see linux-vdso.so.1 points to different memory location. This has been done as if no one can predict the address up front.

vsyscall came first, vdso, overcomes its limitations. vsyscall is still used why?

## Links

- https://people.cs.pitt.edu/~xianeizhang/notes/Linking.html
- http://michalmalik.github.io/elf-dynamic-segment-struggles
- https://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html#cpp
- [Hosted vs Freestanding Environments](https://stackoverflow.com/questions/30825151/is-there-a-meaningful-distinction-between-freestanding-and-hosted-implementation)
- [20 Part Seies on Linkers and Loaders](https://www.airs.com/blog/archives/41)
- linkers and loaders book.

## Tools

- `nm`: We can see the symbols in a object file using `nm`
- `size`
- `file`
- `execstack`
- `readelf`
- `ldd`
- `hexdump`
- `objdump` : look at symbol table entries , readelf can also be used.
- objdump -r -d -t main.o
- readelf -s main.o
